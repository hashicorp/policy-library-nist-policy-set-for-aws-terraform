# S3 Buckets should have encryption enabled at rest with AWS KMS Key

# Imports

import "tfconfig/v2" as tfconfig
import "tfresources" as tf
import "report" as report
import "collection" as collection
import "collection/maps" as maps
import "strings"
import "types"

# Constants

const = {
	"policy_name":                                                 "s3-bucket=should-be-encrypted-at-rest",
	"message":                                                     "S3 Buckets should have encryption enabled at rest with AWS KMS Key. Refer to https://docs.aws.amazon.com/securityhub/latest/userguide/s3-controls.html#s3-17 for more details.",
	"resource_aws_s3_bucket":                                      "aws_s3_bucket",
	"resource_aws_s3_bucket_server_side_encryption_configuration": "aws_s3_bucket_server_side_encryption_configuration",
	"address":        "address",
	"module_address": "module_address",
	"module_prefix":  "module.",
	"rule":           "rule",
	"apply_server_side_encryption_by_default": "apply_server_side_encryption_by_default",
	"sse_algorithm":                           "sse_algorithm",
	"kms_master_key_id":                       "kms_master_key_id",
	"aes256":                                  "AES256",
	"default_kms_key":                         "aws/s3",
}

# Functions

# Prefixes the referenced S3 Bucket's address with
# the module address. This is done because resource
# addresses comprise of module addresses
sanitize_compliant_s3_bucket_address = func(res) {
	module_addr = res[const.module_address]
	if res.config.bucket.constant_value is defined {
		return ""
	}
	rule_block = maps.get(res.config, const.rule, [])
	if rule_block is empty {
		return ""
	}

	apply_server_side_encryption_values = maps.get(rule_block[0], const.apply_server_side_encryption_by_default, [])
	if apply_server_side_encryption_values is empty {
		return ""
	}

	sse_algorithm = maps.get(apply_server_side_encryption_values[0], const.sse_algorithm, "").constant_value
	if sse_algorithm is empty or sse_algorithm is const.aes256 {
		return ""
	}

	kms_key = maps.get(apply_server_side_encryption_values[0], const.kms_master_key_id, "")
	if kms_key is empty or kms_key.constant_value is defined and (kms_key.constant_value is empty or kms_key.constant_value is const.default_kms_key) {
		return ""
	}

	s3_bucket_reference = res.config.bucket.references[1]
	# Check for root module
	if not strings.has_prefix(res[const.address], const.module_prefix) {
		return s3_bucket_reference
	}

	return module_addr + "." + s3_bucket_reference
}

# Variables

config_resources = tf.config(tfconfig.resources)
bucket_resources = config_resources.type(const.resource_aws_s3_bucket).resources
bucket_encryption_resources = config_resources.type(const.resource_aws_s3_bucket_server_side_encryption_configuration).resources

# Get S3 Bucket addresses that have object lock enabled
s3_bucket_addresses_with_encryption = map bucket_encryption_resources as _, res {
	sanitize_compliant_s3_bucket_address(res)
}

# Find violations: S3 Buckets that have policy violations
violations = filter bucket_resources as _, res {
	res.address not in s3_bucket_addresses_with_encryption
}

summary = {
	"policy_name": const.policy_name,
	"violations": map violations as _, v {
		{
			"address":        v.address,
			"module_address": v.module_address,
			"message":        const.message,
		}
	},
}

print(report.generate_policy_report(summary))

main = rule {
	violations is empty
}
